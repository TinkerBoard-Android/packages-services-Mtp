/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.mtp;

import android.content.ContentValues;
import android.content.Context;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.DatabaseUtils;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.mtp.MtpObjectInfo;
import android.provider.DocumentsContract;
import android.provider.DocumentsContract.Document;

import com.android.internal.annotations.VisibleForTesting;

import java.util.Objects;

/**
 * Database for MTP objects.
 * The object handle which is identifier for object in MTP protocol is not stable over sessions.
 * When we resume the process, we need to remap our document ID with MTP's object handle.
 *
 * If the remote MTP device is backed by typical file system, the file name
 * is unique among files in a directory. However, MTP protocol itself does
 * not guarantee the uniqueness of name so we cannot use fullpath as ID.
 *
 * Instead of fullpath, we use artificial ID generated by MtpDatabase itself. The database object
 * remembers the map of document ID and object handle, and remaps new object handle with document ID
 * by comparing the directory structure and object name.
 *
 * TODO: Remove @VisibleForTesting annotation when we start to use this class.
 * TODO: Improve performance by SQL optimization.
 */
@VisibleForTesting
class MtpDatabase {
    private static final int VERSION = 1;
    private static final String NAME = "mtp";

    private static final String TABLE_DOCUMENTS = "Documents";

    static final String COLUMN_DEVICE_ID = "device_id";
    static final String COLUMN_STORAGE_ID = "storage_id";
    static final String COLUMN_OBJECT_HANDLE = "object_handle";
    static final String COLUMN_PARENT_DOCUMENT_ID = "parent_document_id";
    static final String COLUMN_ROW_STATE = "row_state";

    /**
     * The state represents that the row has a valid object handle.
     */
    static final int ROW_STATE_MAPPED = 0;

    /**
     * The state represents that the object handle was cleared because the MTP session closed.
     * External application can still fetch the unmapped documents. If the external application
     * tries to open an unmapped document, the provider resolves the document with new object handle
     * ahead.
     */
    static final int ROW_STATE_UNMAPPED = 1;

    /**
     * The state represents the raw has a valid object handle but it may be going to be merged into
     * another unmapped row. After fetching all documents under the parent, the database tries to
     * map the mapping document and the unmapped document in order to keep old document ID alive.
     */
    static final int ROW_STATE_MAPPING = 2;

    private static final String SELECTION_DOCUMENT_ID =
            DocumentsContract.Document.COLUMN_DOCUMENT_ID + " = ?";
    private static final String SELECTION_ROOT_DOCUMENTS =
            COLUMN_DEVICE_ID + " = ? AND " + COLUMN_PARENT_DOCUMENT_ID + " IS NULL";
    private static final String SELECTION_CHILD_DOCUMENTS = COLUMN_PARENT_DOCUMENT_ID + " = ?";

    static class ParentNotFoundException extends Exception {}

    private static class OpenHelper extends SQLiteOpenHelper {
        private static final String QUERY_CREATE_DOCUMENTS =
                "CREATE TABLE " + TABLE_DOCUMENTS + " (" +
                DocumentsContract.Document.COLUMN_DOCUMENT_ID +
                    " INTEGER PRIMARY KEY AUTOINCREMENT," +
                COLUMN_DEVICE_ID + " INTEGER NOT NULL," +
                COLUMN_STORAGE_ID + " INTEGER," +
                COLUMN_OBJECT_HANDLE + " INTEGER," +
                COLUMN_PARENT_DOCUMENT_ID + " INTEGER," +
                COLUMN_ROW_STATE + " INTEGER NOT NULL," +
                DocumentsContract.Document.COLUMN_MIME_TYPE + " TEXT," +
                DocumentsContract.Document.COLUMN_DISPLAY_NAME + " TEXT NOT NULL," +
                DocumentsContract.Document.COLUMN_SUMMARY + " TEXT," +
                DocumentsContract.Document.COLUMN_LAST_MODIFIED + " INTEGER," +
                DocumentsContract.Document.COLUMN_ICON + " INTEGER," +
                DocumentsContract.Document.COLUMN_FLAGS + " INTEGER NOT NULL," +
                DocumentsContract.Document.COLUMN_SIZE + " INTEGER NOT NULL);";

        public OpenHelper(Context context) {
            super(context, NAME, null, VERSION);
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            db.execSQL(QUERY_CREATE_DOCUMENTS);
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            throw new UnsupportedOperationException();
        }
    }

    private final SQLiteDatabase database;

    @VisibleForTesting
    MtpDatabase(Context context) {
        final OpenHelper helper = new OpenHelper(context);
        database = helper.getWritableDatabase();
    }

    @VisibleForTesting
    static void deleteDatabase(Context context) {
        SQLiteDatabase.deleteDatabase(context.getDatabasePath(NAME));
    }

    @VisibleForTesting
    Cursor queryRootDocuments(String[] columnNames) {
        return database.query(
                TABLE_DOCUMENTS,
                columnNames,
                COLUMN_ROW_STATE + " IN (?, ?)",
                strings(ROW_STATE_MAPPED, ROW_STATE_UNMAPPED),
                null,
                null,
                null);
    }

    @VisibleForTesting
    Cursor queryChildDocuments(String[] columnNames, String parentDocumentId) {
        return database.query(
                TABLE_DOCUMENTS,
                columnNames,
                COLUMN_ROW_STATE + " IN (?, ?) AND " + COLUMN_PARENT_DOCUMENT_ID + " = ?",
                strings(ROW_STATE_MAPPED, ROW_STATE_UNMAPPED, parentDocumentId),
                null,
                null,
                null);
    }

    @VisibleForTesting
    void putRootDocuments(int deviceId, Resources resources, MtpRoot[] roots) {
        final ContentValues[] valuesList = new ContentValues[roots.length];
        for (int i = 0; i < roots.length; i++) {
            if (roots[i].mDeviceId != deviceId) {
                throw new IllegalArgumentException();
            }
            valuesList[i] = new ContentValues();
            getRootDocumentValues(valuesList[i], resources, roots[i]);
        }
        putDocuments(valuesList, SELECTION_ROOT_DOCUMENTS, Integer.toString(deviceId));
    }

    @VisibleForTesting
    void putChildDocuments(int deviceId, String parentId, MtpObjectInfo[] documents) {
        final ContentValues[] valuesList = new ContentValues[documents.length];
        for (int i = 0; i < documents.length; i++) {
            valuesList[i] = new ContentValues();
            getChildDocumentValues(valuesList[i], deviceId, parentId, documents[i]);
        }
        putDocuments(valuesList, SELECTION_CHILD_DOCUMENTS, parentId);
    }

    /**
     * Clears MTP related identifier.
     * It clears MTP's object handle and storage ID that are not stable over MTP sessions and mark
     * the all documents as 'unmapped'. It also remove 'mapping' rows as mapping is cancelled now.
     */
    @VisibleForTesting
    void clearMapping() {
        database.beginTransaction();
        try {
            database.delete(
                    TABLE_DOCUMENTS, COLUMN_ROW_STATE + " = ?", strings(ROW_STATE_MAPPING));
            final ContentValues values = new ContentValues();
            values.putNull(COLUMN_OBJECT_HANDLE);
            values.putNull(COLUMN_STORAGE_ID);
            values.put(COLUMN_ROW_STATE, ROW_STATE_UNMAPPED);
            database.update(TABLE_DOCUMENTS, values, null, null);
            database.setTransactionSuccessful();
        } finally {
            database.endTransaction();
        }
    }

    @VisibleForTesting
    void resolveRootDocuments(int deviceId) {
        resolveDocuments(SELECTION_ROOT_DOCUMENTS, Integer.toString(deviceId));
    }

    @VisibleForTesting
    void resolveChildDocuments(String parentId) {
        resolveDocuments(SELECTION_CHILD_DOCUMENTS, parentId);
    }

    /**
     * Puts the documents into the database.
     * If the database found another unmapped document that shares the same name and parent,
     * the document may be merged into the unmapped document. In that case, the database marks the
     * root as 'mapping' and wait for {@link #resolveRootDocuments(int)} is invoked.
     * @param valuesList Values that are stored in the database.
     * @param selection SQL where closure to select rows that shares the same parent.
     * @param arg Argument for selection SQL.
     */
    private void putDocuments(ContentValues[] valuesList, String selection, String arg) {
        database.beginTransaction();
        try {
            for (final ContentValues values : valuesList) {
                final String displayName =
                        values.getAsString(DocumentsContract.Document.COLUMN_DISPLAY_NAME);
                final long numUnmapped = DatabaseUtils.queryNumEntries(
                        database,
                        TABLE_DOCUMENTS,
                        selection + " AND " +
                        COLUMN_ROW_STATE + " = ? AND " +
                        DocumentsContract.Document.COLUMN_DISPLAY_NAME + " = ?",
                        strings(arg, ROW_STATE_UNMAPPED, displayName));
                if (numUnmapped != 0) {
                    values.put(COLUMN_ROW_STATE, ROW_STATE_MAPPING);
                }
                database.insert(TABLE_DOCUMENTS, null, values);
            }

            database.setTransactionSuccessful();
        } finally {
            database.endTransaction();
        }
    }

    /**
     * Maps 'unmapped' document and 'mapping' document that don't have document but shares the same
     * name.
     * If the database does not find corresponding 'mapping' document, it just removes 'unmapped'
     * document from the database.
     * @param selection Query to select rows for resolving.
     * @param arg Argument for selection SQL.
     */
    private void resolveDocuments(String selection, String arg) {
        database.beginTransaction();
        try {
            // Get 1-to-1 mapping of unmapped document and mapping document.
            final String unmappedIdQuery = createStateFilter(
                    ROW_STATE_UNMAPPED, DocumentsContract.Document.COLUMN_DOCUMENT_ID);
            final String mappingIdQuery = createStateFilter(
                    ROW_STATE_MAPPING, DocumentsContract.Document.COLUMN_DOCUMENT_ID);
            // SQL should be like:
            // SELECT group_concat(CASE WHEN raw_state = 1 THEN document_id ELSE NULL END),
            //        group_concat(CASE WHEN raw_state = 2 THEN document_id ELSE NULL END)
            // WHERE device_id = ? AND parent_document_id IS NULL
            // GROUP BY display_name
            // HAVING count(CASE WHEN raw_state = 1 THEN document_id ELSE NULL END) = 1 AND
            //        count(CASE WHEN raw_state = 2 THEN document_id ELSE NULL END) = 1
            final Cursor mergingCursor = database.query(
                    TABLE_DOCUMENTS,
                    new String[] {
                            "group_concat(" + unmappedIdQuery + ")",
                            "group_concat(" + mappingIdQuery + ")"
                    },
                    selection,
                    strings(arg),
                    DocumentsContract.Document.COLUMN_DISPLAY_NAME,
                    "count(" + unmappedIdQuery + ") = 1 AND count(" + mappingIdQuery + ") = 1",
                    null);

            final ContentValues values = new ContentValues();
            while (mergingCursor.moveToNext()) {
                final String unmappedId = mergingCursor.getString(0);
                final String mappingId = mergingCursor.getString(1);

                // Obtain the new values including the latest object handle from mapping row.
                final Cursor mappingCursor = database.query(
                        TABLE_DOCUMENTS,
                        null,
                        SELECTION_DOCUMENT_ID,
                        new String[] { mappingId },
                        null,
                        null,
                        null);
                mappingCursor.moveToNext();
                values.clear();
                DatabaseUtils.cursorRowToContentValues(mappingCursor, values);
                mappingCursor.close();
                values.remove(DocumentsContract.Document.COLUMN_DOCUMENT_ID);

                // Set the new values into unmapped documents and get it back to 'normal' state.
                values.put(COLUMN_ROW_STATE, ROW_STATE_MAPPED);
                database.update(
                        TABLE_DOCUMENTS,
                        values,
                        SELECTION_DOCUMENT_ID,
                        new String[] { unmappedId });

                // Delete 'mapping' row.
                database.delete(
                        TABLE_DOCUMENTS,
                        SELECTION_DOCUMENT_ID,
                        new String[] { mappingId });
            }
            mergingCursor.close();

            // Delete all unmapped rows that cannot be mapped.
            database.delete(
                    TABLE_DOCUMENTS,
                    COLUMN_ROW_STATE + " = ? AND " + selection,
                    strings(ROW_STATE_UNMAPPED, arg));

            // The database cannot find old document ID for the mapping rows.
            // Turn the all mapping rows into mapped state, which means the rows become to be
            // valid with new document ID.
            values.clear();
            values.put(COLUMN_ROW_STATE, ROW_STATE_MAPPED);
            database.update(
                    TABLE_DOCUMENTS,
                    values,
                    COLUMN_ROW_STATE + " = ? AND " + selection,
                    strings(ROW_STATE_MAPPING, arg));
            database.setTransactionSuccessful();
        } finally {
            database.endTransaction();
        }
    }

    /**
     * Gets {@link ContentValues} for the given root.
     * @param values {@link ContentValues} that receives values.
     * @param resources Resources used to get localized root name.
     * @param root Root to be converted {@link ContentValues}.
     */
    private static void getRootDocumentValues(
            ContentValues values, Resources resources, MtpRoot root) {
        values.clear();
        values.put(COLUMN_DEVICE_ID, root.mDeviceId);
        values.put(COLUMN_STORAGE_ID, root.mStorageId);
        values.putNull(COLUMN_OBJECT_HANDLE);
        values.putNull(COLUMN_PARENT_DOCUMENT_ID);
        values.put(COLUMN_ROW_STATE, ROW_STATE_MAPPED);
        values.put(Document.COLUMN_MIME_TYPE, DocumentsContract.Document.MIME_TYPE_DIR);
        values.put(Document.COLUMN_DISPLAY_NAME, root.getRootName(resources));
        values.putNull(Document.COLUMN_SUMMARY);
        values.putNull(Document.COLUMN_LAST_MODIFIED);
        values.putNull(Document.COLUMN_ICON);
        values.put(Document.COLUMN_FLAGS, 0);
        values.put(Document.COLUMN_SIZE,
                (int) Math.min(root.mMaxCapacity - root.mFreeSpace, Integer.MAX_VALUE));
    }

    /**
     * Gets {@link ContentValues} for the given MTP object.
     * @param values {@link ContentValues} that receives values.
     * @param deviceId Device ID of the object.
     * @param parentId Parent document ID of the object.
     * @param info MTP object info.
     */
    private void getChildDocumentValues(
            ContentValues values, int deviceId, String parentId, MtpObjectInfo info) {
        values.clear();
        final String mimeType = CursorHelper.formatTypeToMimeType(info.getFormat());
        int flag = 0;
        if (info.getProtectionStatus() == 0) {
            flag |= DocumentsContract.Document.FLAG_SUPPORTS_DELETE |
                    DocumentsContract.Document.FLAG_SUPPORTS_WRITE;
            if (mimeType == DocumentsContract.Document.MIME_TYPE_DIR) {
                flag |= DocumentsContract.Document.FLAG_DIR_SUPPORTS_CREATE;
            }
        }
        if (info.getThumbCompressedSize() > 0) {
            flag |= DocumentsContract.Document.FLAG_SUPPORTS_THUMBNAIL;
        }
        values.put(COLUMN_DEVICE_ID, deviceId);
        values.put(COLUMN_STORAGE_ID, info.getStorageId());
        values.put(COLUMN_OBJECT_HANDLE, info.getObjectHandle());
        values.put(COLUMN_PARENT_DOCUMENT_ID, parentId);
        values.put(COLUMN_ROW_STATE, ROW_STATE_MAPPED);
        values.put(Document.COLUMN_MIME_TYPE, mimeType);
        values.put(Document.COLUMN_DISPLAY_NAME, info.getName());
        values.putNull(Document.COLUMN_SUMMARY);
        values.put(
                Document.COLUMN_LAST_MODIFIED,
                info.getDateModified() != 0 ? info.getDateModified() : null);
        values.putNull(Document.COLUMN_ICON);
        values.put(Document.COLUMN_FLAGS, flag);
        values.put(Document.COLUMN_SIZE, info.getCompressedSize());
    }

    /**
     * Converts values into string array.
     * @param args Values converted into string array.
     * @return String array.
     */
    private static String[] strings(Object... args) {
        final String[] results = new String[args.length];
        for (int i = 0; i < args.length; i++) {
            results[i] = Objects.toString(args[i]);
        }
        return results;
    }

    /**
     * Gets SQL expression that represents the given value or NULL depends on the row state.
     * @param state Expected row state.
     * @param a SQL value.
     * @return Expression that represents a if the row state is expected one, and represents NULL
     *     otherwise.
     */
    private static String createStateFilter(int state, String a) {
        return "CASE WHEN " + COLUMN_ROW_STATE + " = " + Integer.toString(state) +
                " THEN " + a + " ELSE NULL END";
    }
}
